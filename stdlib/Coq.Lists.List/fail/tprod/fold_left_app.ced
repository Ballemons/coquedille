module test.
data list (A : ★) : ★ =
  | nil : list
  | cons : A ➔ list ➔ list.

list_ind : ∀ A : ★ . ∀ P : Π l : list ·A . ★ . Π f : P (nil ·A) . Π f' : Π a : A . Π l : list ·A . P l ➔ P (cons ·A a l) . Π l : list ·A . P l = Λ A : ★ . Λ P : Π l : list ·A . ★ . λ f : P (nil ·A) . λ f' : Π a : A . Π l : list ·A . P l ➔ P (cons ·A a l) . λ l : list ·A . μ F. l @(λ l : list ·A . P l) {
  | nil ➔ f 
  | cons y l' ➔ f' y (to/list -isType/F l') (F l') 
 }.

data eq (A : ★) (x : A) : A ➔ ★ =
  | eq_refl : eq x.

fold_left : ∀ A : ★ . ∀ B : ★ . Π f : A ➔ B ➔ A . Π l : list ·B . Π a0 : A . A = Λ A : ★ . Λ B : ★ . λ f : A ➔ B ➔ A . λ l : list ·B . λ a0 : A . μ fold_left. l @(λ l : list ·B . Π a0 : A . A) {
  | nil ➔ λ _ . a0 
  | cons b t ➔ λ _ . fold_left t (f a0 b) 
 } a0.

app : ∀ A : ★ . list ·A ➔ list ·A ➔ list ·A = Λ A : ★ . λ l : list ·A . λ m : list ·A . μ app. l @(λ l : list ·A . Π m : list ·A . list ·A) {
  | nil ➔ λ _ . m 
  | cons a l1 ➔ λ _ . cons ·A a (app l1 m) 
 } m.

fold_left_app : ∀ A : ★ . ∀ B : ★ . Π f : A ➔ B ➔ A . Π l : list ·B . Π l' : list ·B . Π i : A . eq ·A (fold_left ·A ·B f (app ·B l l') i) (fold_left ·A ·B f l' (fold_left ·A ·B f l i)) = Λ A : ★ . Λ B : ★ . λ f : A ➔ B ➔ A . λ l : list ·B . list_ind ·B (λ l' : list ·B . tprodT?) (λ l' : list ·B . λ i : A . eq_refl ·A (fold_left ·A ·B f l' i)) (λ a : B . λ l' : list ·B . λ IHl : Π l'' : list ·B . Π i : A . eq ·A (fold_left ·A ·B f (app ·B l' l'') i) (fold_left ·A ·B f l'' (fold_left ·A ·B f l' i)) . λ l'' : list ·B . λ i : A . IHl l'' (f i a)) l.


